// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(["DisplayObject"], function(DisplayObject) {
    var Graph;
    return Graph = (function(superClass) {
      extend(Graph, superClass);

      function Graph(options) {
        Graph.__super__.constructor.call(this, options);
        this._commands = [];
        this.needAnimation = false;
      }

      Graph.prototype.line = function(fromX, fromY, toX, toY) {
        var from, to;
        from = this._point(fromX, fromY);
        to = this._point(toX, toY);
        this._commands.push({
          "command": "line",
          "from": from,
          "to": to
        });
        return this.needAnimation = true;
      };

      Graph.prototype.clear = function() {
        this._commands = [];
        return this.needAnimation = true;
      };

      Graph.prototype.strokeStyle = function(style) {
        return this._commands.push({
          "command": "strokeStyle",
          "style": style
        });
      };

      Graph.prototype.fillStyle = function(style) {
        return this._commands.push({
          "command": "fillStyle",
          "style": style
        });
      };

      Graph.prototype.fillRect = function(fromX, fromY, width, height) {
        var point, sizes;
        point = this._point(fromX, fromY);
        sizes = this._point(width, height);
        this._commands.push({
          "command": "fillRect",
          "point": point,
          "sizes": sizes
        });
        return this.needAnimation = true;
      };

      Graph.prototype.moveTo = function(toX, toY) {
        var point;
        point = this._point(toX, toY);
        return this._commands.push({
          "command": "moveTo",
          "point": point
        });
      };

      Graph.prototype.lineTo = function(toX, toY) {
        var point;
        point = this._point(toX, toY);
        return this._commands.push({
          "command": "lineTo",
          "point": point
        });
      };

      Graph.prototype.polyline = function(points, stroke) {
        if (stroke == null) {
          stroke = true;
        }
        this._commands.push({
          "command": "beginPath"
        });
        this.moveTo(points[0][0], points[0][1]);
        points.forEach((function(_this) {
          return function(point) {
            return _this.lineTo(point[0], point[1]);
          };
        })(this));
        if (stroke) {
          this._commands.push({
            "command": "stroke"
          });
        }
        return this.needAnimation = true;
      };

      Graph.prototype.polygon = function(points) {
        this.polyline(points, false);
        this.lineTo(points[0][0], points[0][1]);
        this._commands.push({
          "command": "stroke"
        });
        this._commands.push({
          "command": "fill"
        });
        return this.needAnimation = true;
      };

      Graph.prototype.lineWidth = function(width) {
        width = this._int(width);
        return this._commands.push({
          "command": "lineWidth",
          "width": width
        });
      };

      Graph.prototype.setLineDash = function(dash) {
        return this._commands.push({
          "command": "setDash",
          "dash": dash
        });
      };

      Graph.prototype.lineDashOffset = function(offset) {
        offset = this._int(offset);
        return this._commands.push({
          "command": "dashOffset",
          "offset": offset
        });
      };

      Graph.prototype.animate = function(context) {
        Graph.__super__.animate.call(this, context);
        context.lineCap = "round";
        this._commands.forEach((function(_this) {
          return function(command) {
            switch (command.command) {
              case "beginPath":
                return context.beginPath();
              case "stroke":
                return context.stroke();
              case "fill":
                return context.fill();
              case "setDash":
                return context.setLineDash(command.dash);
              case "dashOffset":
                return context.lineDashOffset = command.offset;
              case "moveTo":
                return context.moveTo(command.point[0] + _this._deltaX, command.point[1] + _this._deltaY);
              case "lineTo":
                return context.lineTo(command.point[0] + _this._deltaX, command.point[1] + _this._deltaY);
              case "line":
                context.beginPath();
                context.moveTo(command.from[0] + _this._deltaX, command.from[1] + _this._deltaY);
                context.lineTo(command.to[0] + _this._deltaX, command.to[1] + _this._deltaY);
                return context.stroke();
              case "strokeStyle":
                return context.strokeStyle = command.style;
              case "fillStyle":
                return context.fillStyle = command.style;
              case "lineWidth":
                return context.lineWidth = command.width;
              case "fillRect":
                return context.fillRect(command.point[0] + _this._deltaX, command.point[1] + _this._deltaY, command.sizes[0], command.sizes[1]);
            }
          };
        })(this));
        context.restore();
        return this.needAnimation = false;
      };

      return Graph;

    })(DisplayObject);
  });

}).call(this);
