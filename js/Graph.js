// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(["DisplayObject"], function(DisplayObject) {
    var Graph;
    return Graph = (function(superClass) {
      extend(Graph, superClass);

      function Graph(options) {
        Graph.__super__.constructor.call(this, options);
        this._commands = [];
        this.needAnimation = false;
      }

      Graph.prototype.line = function(fromX, fromY, toX, toY) {
        var from, to;
        from = this._point(fromX, fromY);
        to = this._point(toX, toY);
        this._commands.push({
          "command": "line",
          "from": from,
          "to": to
        });
        return this.needAnimation = true;
      };

      Graph.prototype.clear = function() {
        this._commands = [];
        return this.needAnimation = true;
      };

      Graph.prototype.strokeStyle = function(style) {
        return this._commands.push({
          "command": "strokeStyle",
          "style": style
        });
      };

      Graph.prototype.fillStyle = function(style) {
        return this._commands.push({
          "command": "fillStyle",
          "style": style
        });
      };

      Graph.prototype.rect = function(fromX, fromY, width, height, radius) {
        var point, sizes;
        if (radius == null) {
          radius = 0;
        }
        point = this._point(fromX, fromY);
        sizes = this._point(width, height);
        this._commands.push({
          "command": "rect",
          "point": point,
          "sizes": sizes,
          "radius": radius
        });
        return this.needAnimation = true;
      };

      Graph.prototype.moveTo = function(toX, toY) {
        var point;
        point = this._point(toX, toY);
        return this._commands.push({
          "command": "moveTo",
          "point": point
        });
      };

      Graph.prototype.lineTo = function(toX, toY) {
        var point;
        point = this._point(toX, toY);
        this._commands.push({
          "command": "lineTo",
          "point": point
        });
        return this.needAnimation = true;
      };

      Graph.prototype.fill = function() {
        this._commands.push({
          "command": "fill"
        });
        return this.needAnimation = true;
      };

      Graph.prototype.stroke = function() {
        this._commands.push({
          "command": "stroke"
        });
        return this.needAnimation = true;
      };

      Graph.prototype.polyline = function(points, stroke) {
        if (stroke == null) {
          stroke = true;
        }
        this._commands.push({
          "command": "beginPath"
        });
        this.moveTo(points[0][0], points[0][1]);
        points.forEach((function(_this) {
          return function(point) {
            return _this.lineTo(point[0], point[1]);
          };
        })(this));
        if (stroke) {
          this._commands.push({
            "command": "stroke"
          });
        }
        return this.needAnimation = true;
      };

      Graph.prototype.polygon = function(points) {
        this.polyline(points, false);
        this.lineTo(points[0][0], points[0][1]);
        this._commands.push({
          "command": "stroke"
        });
        this._commands.push({
          "command": "fill"
        });
        return this.needAnimation = true;
      };

      Graph.prototype.lineWidth = function(width) {
        width = this._int(width);
        return this._commands.push({
          "command": "lineWidth",
          "width": width
        });
      };

      Graph.prototype.setLineDash = function(dash) {
        return this._commands.push({
          "command": "setDash",
          "dash": dash
        });
      };

      Graph.prototype.lineDashOffset = function(offset) {
        offset = this._int(offset);
        return this._commands.push({
          "command": "dashOffset",
          "offset": offset
        });
      };

      Graph.prototype._drawRoundedRect = function(context, x, y, width, height, radius) {
        var halfpi, pi, x1, x2, y1, y2;
        pi = Math.PI;
        halfpi = pi / 2;
        x1 = x + radius;
        x2 = x + width - radius;
        y1 = y + radius;
        y2 = y + height - radius;
        context.moveTo(x1, y);
        context.lineTo(x2, y);
        context.arc(x2, y1, radius, -halfpi, 0);
        context.lineTo(x + width, y2);
        context.arc(x2, y2, radius, 0, halfpi);
        context.lineTo(x1, y + height);
        context.arc(x1, y2, radius, halfpi, pi);
        context.lineTo(x, y1);
        return context.arc(x1, y1, radius, pi, 3 * halfpi);
      };

      Graph.prototype.animate = function(context) {
        Graph.__super__.animate.call(this, context);
        context.lineCap = "round";
        this._commands.forEach((function(_this) {
          return function(command) {
            switch (command.command) {
              case "beginPath":
                return context.beginPath();
              case "stroke":
                return context.stroke();
              case "fill":
                return context.fill();
              case "setDash":
                return context.setLineDash(command.dash);
              case "dashOffset":
                return context.lineDashOffset = command.offset;
              case "moveTo":
                return context.moveTo(command.point[0] + _this._deltaX, command.point[1] + _this._deltaY);
              case "lineTo":
                return context.lineTo(command.point[0] + _this._deltaX, command.point[1] + _this._deltaY);
              case "line":
                context.beginPath();
                context.moveTo(command.from[0] + _this._deltaX, command.from[1] + _this._deltaY);
                context.lineTo(command.to[0] + _this._deltaX, command.to[1] + _this._deltaY);
                return context.stroke();
              case "strokeStyle":
                return context.strokeStyle = command.style;
              case "fillStyle":
                return context.fillStyle = command.style;
              case "lineWidth":
                return context.lineWidth = command.width;
              case "rect":
                context.beginPath();
                if (command.radius === 0) {
                  return context.rect(command.point[0] + _this._deltaX, command.point[1] + _this._deltaY, command.sizes[0], command.sizes[1]);
                } else {
                  return _this._drawRoundedRect(context, command.point[0] + _this._deltaX, command.point[1] + _this._deltaY, command.sizes[0], command.sizes[1], command.radius);
                }
            }
          };
        })(this));
        context.restore();
        return this.needAnimation = false;
      };

      return Graph;

    })(DisplayObject);
  });

}).call(this);
