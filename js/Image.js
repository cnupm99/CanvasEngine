// Generated by CoffeeScript 2.0.2
(function() {
  "use strict";
  var boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  define(["DisplayObject"], function(DisplayObject) {
    var Image;
    return Image = class Image extends DisplayObject {
      
      // Класс для загрузки и отображения изображений

      // свойства:

      //  onload:Function - ссылка на функцию, которая должна выполниться после загрузки картинки
      //  loaded:Boolean - загружена ли картинка
      //  image:Image - объект картинки
      //  loadedFrom:String - строка с адресом картинки
      //  rect:Array - прямоугольник для отображения части картинки

      // методы:

      //  src(url:string): загрузка картинки с указанным адресом
      //  from(image:Image, url:String) - создание из уже существующей и загруженной картинки
      //  setRect(rect:Array):Array - установка области для отображения только части картинки
      //  animate() - попытка нарисовать объект

      constructor(options) {
        super(options);
        this._imageOnLoad = this._imageOnLoad.bind(this);
        
        // тип объекта

        this.type = "image";
        
        // событие, выполняемое при загрузке картинки

        this.onload = options.onload;
        
        // Загружена ли картинка,
        // в данный момент нет,
        // а значит рисовать ее не нужно

        this.loaded = false;
        
        // создаем элемент

        this.image = document.createElement("img");
        
        // Событие при загрузке картинки

        this.image.onload = this._imageOnLoad;
        
        // Здесь будем хранить src картинки как строку.
        // При вызове src картика загружается, а адрес устанавливается в loadedFrom
        // При присвоении loadedFrom картинка не загружается
        // Это просто строка для хранения адреса картинки

        this.loadedFrom = "";
        
        // свойство для отображения только части картинки

        this.setRect(options.rect);
        
        // нужно ли загружать картинку

        if (options.src != null) {
          this.src(options.src);
        } else {
          
          // или она уже загружена

          this.from(options.from);
        }
      }

      
      // Установка области

      setRect(value) {
        this.rect = value || false;
        this.needAnimation = true;
        return this.rect;
      }

      
      // Метод для загрузки картики

      src(value) {
        this.loaded = false;
        this.loadedFrom = value;
        // загружаем
        return this.image.src = value;
      }

      
      // Создание картинки из уже созданной и загруженной

      // 	image: Image
      // 	src: String // не обязательно

      from(from, src) {
        
        // если картинки нет, то нет смысла продолжать

        if (from == null) {
          return;
        }
        
        // а вот и картинка

        this.image = from;
        
        // Запоминаем src

        this.loadedFrom = src || "";
        
        // запоминаем реальные размеры

        this.upsize([this.image.width, this.image.height]);
        if (this.size[0] <= 0 || this.size[1] <= 0) {
          
          // если нужно меняем размеры
          // иначе потом будем масштабировать

          this.resize(this.realSize);
        }
        // можно рисовать
        this.loaded = true;
        return this.needAnimation = true;
      }

      animate() {
        
        // если картинка не загружена, то рисовать ее не будем

        if (!this.loaded) {
          return;
        }
        
        // если объект не видимый
        // то рисовать его не нужно

        if (!this.visible) {
          this.needAnimation = false;
          return;
        }
        
        // действия по умолчанию для DisplayObject

        super.animate();
        
        // если нужно рисовать определенную область изображения

        if (this.rect) {
          
          // вырезаем и рисуем в нужном масштабе определенную область картинки

          return this.context.drawImage(this.image, this.rect[0], this.rect[1], this.rect[2], this.rect[3], this._deltaX, this._deltaY, this.size[0], this.size[1]);
        } else {
          
          // рисуем в реальном размере?

          if (this.size[0] === this.realSize[0] && this.size[1] === this.realSize[1]) {
            return this.context.drawImage(this.image, this._deltaX, this._deltaY);
          } else {
            
            // тут просто масштабируем картинку

            return this.context.drawImage(this.image, this._deltaX, this._deltaY, this.size[0], this.size[1]);
          }
        }
      }

      _imageOnLoad(e) {
        boundMethodCheck(this, Image);
        
        // запоминаем реальные размеры

        this.upsize([this.image.width, this.image.height]);
        if (this.size[0] <= 0 || this.size[1] <= 0) {
          
          // если нужно меняем размеры
          // иначе потом будем масштабировать

          this.resize(this.realSize);
        }
        this.loaded = true;
        this.needAnimation = true;
        if (this.onload != null) {
          
          // если у картинки есть свойство onload, то вызываем его и
          // сообщаем реальные размеры картинки

          return this.onload(this.realSize);
        }
      }

      
      // возвращаем объект с текущими опциями фигуры

      getOptions() {
        var options;
        
        // базовое

        options = super.getOptions();
        
        // область рисования

        options.rect = this.rect ? [this.rect[0], this.rect[1], this.rect[2], this.rect[3]] : false;
        
        // если загружено

        if (this.loaded) {
          
          // передаем изображение

          options.from = this.image;
          options.loadedFrom = this.loadedFrom;
        } else {
          if (this.loadedFrom.length > 0) {
            
            // пытаемся передать ссылку

            options.src = this.loadedFrom;
          }
        }
        
        // загружено

        options.loaded = this.loaded;
        
        // результат возвращаем

        return options;
      }

    };
  });

}).call(this);
