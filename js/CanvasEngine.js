// Generated by CoffeeScript 2.0.2
(function() {
  "use strict";
  var boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  define(["ContainerObject", "Scene"], function(ContainerObject, Scene) {
    var CanvasEngine;
    
    // Движок для Canvas

    return CanvasEngine = class CanvasEngine extends ContainerObject {
      
      // Главный класс, через него осуществляется взаимодействие с движком

      // свойства:

      //  parent:Element - элемент для отрисовки движка

      // методы:

      //  add(options):DisplayObject - метод для добавления новых объектов / сцен
      //  remove(childName):Boolean - удаляем сцену
      //  onTop(childName):Scene/Boolean - поднимаем сцену на верх отображения
      //  getActive():Scene/Boolean - получить активную сцену
      //  setActive(sceneName:String):Scene - установить активную сцену по имени
      //  start() - запускаем цикл анимации
      //  stop() - останавливаем цикл анимации
      //  addEvent(func) - добавить функцию, выполняемую каждый раз перед анимацией
      //  removeEvent(func) - удалить функцию из цикла анимации
      //  fullscreen(Boolean):Boolean - включить/выключить полноэкранный режим
      //  isFullscreen():Boolean - определяет, включен ли полноэкранный режим
      //  canvasSupport():Boolean - проверка, поддерживает ли браузер canvas и context

      constructor(options) {
        super(options);
        
        // цикл анимации, запускается автоматически,
        // не нужно это делать вручную,
        // для этого есть методы start() и stop()

        this._animate = this._animate.bind(this);
        
        // проверка поддержки канвас и контекст

        if (!this.canvasSupport()) {
          console.log("your browser not support canvas and/or context");
          return false;
        }
        
        // элемент для отрисовки движка
        // свойство ТОЛЬКО ДЛЯ ЧТЕНИЯ

        this.parent = options.parent || document.body;
        
        // если размеры движка не заданы, то пытаемся установить их равными
        // размеру контейнера

        if (this.size[0] === 0 && this.size[1] === 0) {
          this.size = [this.int(this.parent.clientWidth), this.int(this.parent.clientHeight)];
        }
        
        // массив функций для выполнения в цикле перед анимацией

        this._beforeAnimate = [];
        
        // Свойство хранит имя активной сцены в виде строки

        this._scene = "default";
        
        // создаем сцену по умолчанию

        this.add({
          type: "scene",
          name: "default"
        });
        
        // запуск анимации

        this.start();
      }

      
      // Глобальная функция для добавления всего, что угодно

      add(options) {
        var scene, type;
        if (options == null) {
          
          // создаем пустой объект, если необходимо

          options = {};
        }
        
        // тип добавляемого объекта,
        // по умолчанию - сцена

        type = options.type || "scene";
        
        // добавить сцену?

        if (type === "scene") {
          return this._createScene(options);
        } else {
          
          // на какую сцену добавить объект?

          // добавление всего остального, кроме сцен

          scene = this.get(options.scene);
          if (!scene) {
            
            // если в опциях не указана сцена, то добавляем на активную сцену

            scene = this.getActive();
          }
          
          // если в списке нет ниодной сцены, создадим сцену по умолчанию

          if (!scene) {
            scene = this.add({
              type: "scene",
              name: "default"
            });
          }
          
          // добавляем объект на нужную сцену

          return scene.add(options);
        }
      }

      
      // удаляем сцену по ее имени
      // отдельная функция, т.к. тут нужно удалить канвас с элемента

      remove(childName) {
        var index;
        index = this.index(childName);
        if (index === -1) {
          return false;
        }
        this.parent.removeChild(this.childrens[index].canvas);
        this.childrens.splice(index, 1);
        return true;
      }

      
      // переносим сцену на верх отображения
      // для чего делаем ее zIndex на 1 больше максимального из существующих

      onTop(childName) {
        var maxZ, result;
        maxZ = 0;
        result = false;
        this.childrens.forEach(function(child) {
          if (child.zIndex > maxZ) {
            maxZ = child.zIndex;
          }
          if (childName === child.name) {
            return result = child;
          }
        });
        if (result) {
          result.setZIndex(maxZ + 1);
        }
        return result;
      }

      
      // Возвращает активную сцену

      getActive() {
        var result;
        result = this.get(this._scene);
        if (!result) {
          result = this.childrens[0];
        }
        if (!result) {
          result = false;
        }
        return result;
      }

      
      // Устанавливает активную сцену по ее имени

      setActive(sceneName) {
        this._scene = sceneName || "default";
        return this.getActive();
      }

      
      // запуск анимации

      start() {
        return this._render = requestAnimationFrame(this._animate);
      }

      
      // остановка анимации

      stop() {
        return cancelAnimationFrame(this._render);
      }

      
      // добавить функцию для выполнения в цикле
      // функции выполняются в порядке добавления
      // ПЕРЕД аниамацией

      addEvent(func) {
        return this._beforeAnimate.push(func);
      }

      
      // удаление функции из массива
      // эта функция больше не будет выполняться перед анимацией

      removeEvent(func) {
        return this._beforeAnimate.forEach((item, i) => {
          if (item === func) {
            return this._beforeAnimate.splice(i, 1);
          }
        });
      }

      
      // установить / снять полноэкранный режим
      // для элемента parent

      fullscreen(value = true) {
        if (value) {
          if (this.parent.requestFullScreen != null) {
            this.parent.requestFullScreen();
          } else if (this.parent.webkitRequestFullScreen != null) {
            this.parent.webkitRequestFullScreen();
          } else if (this.parent.mozRequestFullScreen != null) {
            this.parent.mozRequestFullScreen();
          } else {
            return false;
          }
        } else {
          if (document.cancelFullScreen != null) {
            document.cancelFullScreen();
          } else if (document.webkitCancelFullScreen != null) {
            document.webkitCancelFullScreen();
          } else if (document.mozCancelFullScreen != null) {
            document.mozCancelFullScreen();
          } else if (document.exitFullScreen != null) {
            document.exitFullScreen();
          } else {
            return false;
          }
        }
        return true;
      }

      // проверка, находится ли документ в полноэкранном режиме
      isFullscreen() {
        var element;
        element = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement;
        return element != null;
      }

      
      // проверка, поддерживает ли браузер canvas и context

      canvasSupport() {
        return document.createElement("canvas").getContext != null;
      }

      
      // создание сцены с нужными опциями

      _createScene(options) {
        var scene;
        if (options.visible == null) {
          
          // если нужно, задаем значения по умолчанию

          options.visible = this.visible;
        }
        if (options.position == null) {
          options.position = this.position;
        }
        if (options.size == null) {
          options.size = this.size;
        }
        if (options.center == null) {
          options.center = this.center;
        }
        if (options.rotation == null) {
          options.rotation = this.rotation;
        }
        if (options.alpha == null) {
          options.alpha = this.alpha;
        }
        if (options.mask == null) {
          options.mask = this.mask;
        }
        if (options.shadow == null) {
          options.shadow = this.shadow;
        }
        
        // передаем родителя, как элемент для создания канваса

        options.parent = this.parent;
        
        // создаем сцену

        scene = new Scene(options);
        
        // добавляем в список дочерних объектов

        this.childrens.push(scene);
        
        // делаем новую сцену активной

        this.setActive(scene.name);
        return scene;
      }

      _animate() {
        boundMethodCheck(this, CanvasEngine);
        
        // выполняем все функции в массиве

        this._beforeAnimate.forEach((func, i) => {
          
          // если это функция, то выполняем ее

          if (typeof func === "function") {
            return func();
          } else {
            
            // а иначе удаляем эту чушь из массива

            return this._beforeAnimate.splice(i, 1);
          }
        });
        
        // АНИМАЦИЯ ТУТ

        // а может не надо?
        this.needAnimation = false;
        
        // перебираем сцены
        this.childrens.forEach((child) => {
          var needAnimation;
          needAnimation = child.needAnimation || child.childrens.some(function(childOfChild) {
            return childOfChild.needAnimation;
          });
          // сохраняем значение
          this.needAnimation = this.needAnimation || needAnimation;
          if (needAnimation) {
            // собственно анимация
            return child.animate();
          }
        });
        
        // продолжаем анимацию

        return this._render = requestAnimationFrame(this._animate);
      }

    };
  });

}).call(this);
