// Generated by CoffeeScript 2.0.2
(function() {
    // CanvasEngine

  // version 1.10
  // build 105
  // Thu Jan 25 2018

  "use strict";
  var boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  define(function() {
    var AbstractObject, CanvasEngine, ContainerObject, DisplayObject, Graph, Image, Scene, Text, TilingImage;
    AbstractObject = (function() {
      
      // Абстрактный объект, не имеющий отображения на экране
      // но вмещающий в себя общедоступные базовые методы

      class AbstractObject {
        
        // методы:

        //  point(value1, value2):Array - приведение выражений к виду [x, y]
        //  pixel(value1, value2):Array - округляет результат pixel
        //  int(value):int - приведение к целому числу
        //  number(value):Number - приведение к числу
        //  deg2rad(value):Number - перевод из градусов в радианы

        // константы:

        //  _PIDIV180 = Math.PI / 180

        constructor(options) {
          if (options == null) {
            
            // если ничего не передано в качестве опций, создаем пустой объект
            // чтобы можно было обратиться к его свойствам

            options = {};
          }
        }

        
        // приведение выражений к виду [x, y]

        // 	все точки хранятся и передаются в виде массивов [x, y]
        // 	чтобы сократить время и объем записей множества точек

        // 	если ничего не передано, возвращает [0, 0]
        // 	если передано два параметра, вернет [value1, value2]
        // 	если первый параметр массив, то вернет [value1[0], value1[1]]
        // 	если первый параметр объект, то вернет [value1.x, value1.y] либо [value1.width, value1.height]
        // 	иначе вeрнет [0, 0]

        point(value1, value2) {
          if (value1 == null) {
            // значение не существует
            return [0, 0];
          }
          if (value2 != null) {
            // передано два параметра, считаем их числами и возвращаем массив
            return [this.number(value1), this.number(value2)];
          }
          // если передан массив
          if (Array.isArray(value1)) {
            // возвращаем первые два элемента
            return [this.number(value1[0]), this.number(value1[1])];
          } else {
            if ((value1.x != null) && (value1.y != null)) {
              // если есть свойства x и y
              // может быть это объект?
              return [this.number(value1.x), this.number(value1.y)];
            }
            if ((value1.width != null) && (value1.height != null)) {
              // если есть свойства width и height
              return [this.number(value1.width), this.number(value1.height)];
            }
            // по умолчанию
            return [0, 0];
          }
        }

        
        // Округляет результ point

        pixel(value1, value2) {
          var result;
          result = this.point(value1, value2);
          return [result[0] >> 0, result[1] >> 0];
        }

        
        // приведение выражения к целому числу

        int(value) {
          return this.number(value) >> 0;
        }

        
        // приведение выражения к числу

        number(value) {
          if (value != null) {
            return +value;
          } else {
            return 0;
          }
        }

        
        // переводим градусы в радианы

        deg2rad(value) {
          return this.number(value) * this._PIDIV180;
        }

      };

      
      // константа, для ускорения рассчетов
      // используется в rad

      AbstractObject.prototype._PIDIV180 = Math.PI / 180;

      return AbstractObject;

    })();
    
    // Абстрактный объект, отображаемый на экране,
    // имеющий для этого все необходимые свойства и методы

    DisplayObject = class DisplayObject extends AbstractObject {
      
      // свойсва:

      //  name:String - имя объекта для его идентификации
      //  type:String - тип объекта
      //  canvas:Canvas - канвас для рисования
      //  context:Context2d - контекст для рисования

      //  visible:Boolean - видимость объекта, устанавливаемая пользователем
      //  position:Array - позиция объекта
      //  size:Array - размер объекта
      //  realSize:Array - реальный размер объкта
      //  center:Array - относительные координаты точки центра объекта, вокруг которой происходит вращение
      //  anchor:Array - дробное число, показывающее, где должен находиться цент относительно размеров объекта
      //  scale:Array - коэффициенты для масштабирования объектов
      //  rotation:int - число в градусах, на которое объект повернут вокруг центра по часовой стрелке
      //  alpha:Number - прозрачность объекта
      //  shadow:Object - тень объекта

      //  needAnimation: Boolean - сообщает движку, нужно ли анимировать объект

      // методы:

      //  set(value:Object) - установка сразу нескольких свойств
      //  show():Boolean - 
      //  hide():Boolean - 
      //  move(value1, value2:int):Array - изменить позицию объекта
      //  shift(deltaX, deltaY:int):Array - сдвигаем объект на нужное смещение по осям
      //  resize(value1, value2:int):Array - изменить размер объекта
      //  upsize(value1, value2:int):Array - обновить реальные размеры объекта
      //  setCenter(value1, value2: int):Array - установить новый центр объекта
      //  setAnchor(value1, value2: Number):Array - установить новый якорь объекта
      //  zoom(value1, value2:Number):Array - установить масштаб объекта
      //  rotate(value:int):int - установить угол поворота объекта
      //  rotateOn(value:int):int - повернуть объект на угол относительно текщего
      //  setAlpha(value:Number):Number - установить прозрачность объекта
      //  setShadow(value:Object): Object - установить тень объекта

      //  testPoint(pointX, pointY:int):Boolean - проверка, пуста ли данная точка
      //  testRect(pointX, pointY:int):Boolean - проверка, входит ли точка в прямоугольник объекта
      //  animate() - попытка нарисовать объект

      constructor(options) {
        var stage;
        
        // конструктор базового класса

        super(options);
        
        // имя, задается пользователем, либо пустая строка
        // используется для поиска по имени

        this.name = options.name || "";
        
        // тип объекта, каждый класс пусть присваивает самостоятельно

        this.type = "DisplayObject";
        
        // канвас для рисования
        // в случае сцены, создается новый канвас
        // в остальных случаях получаем из опций от родителя (сцены)
        // свойство ТОЛЬКО ДЛЯ ЧТЕНИЯ

        if (options.canvas != null) {
          this.canvas = options.canvas;
        } else {
          
          // элемент для добавления канваса
          // всегда должен быть
          // свойство ТОЛЬКО ДЛЯ ЧТЕНИЯ

          stage = options.parent || document.body;
          
          // создаем канвас
          // свойство ТОЛЬКО ДЛЯ ЧТЕНИЯ

          this.canvas = document.createElement("canvas");
          this.canvas.style.position = "absolute";
          stage.appendChild(this.canvas);
        }
        
        // контекст для рисования
        // в случае сцены, берется из канваса,
        // в остальных случаях получаем из опций от родителя (сцены)
        // свойство ТОЛЬКО ДЛЯ ЧТЕНИЯ

        this.context = options.context || this.canvas.getContext("2d");
        
        // установка свойств

        this._setProperties(options);
      }

      
      // Установка всех или определенных свойств через объект опций

      set(options) {
        if (options == null) {
          return;
        }
        if (options.visible != null) {
          this.visible = options.visible;
        }
        if (this.visible) {
          this.show();
        } else {
          this.hide();
        }
        if (options.position != null) {
          this.move(options.position);
        }
        if (options.size != null) {
          this.resize(options.size);
        }
        if (options.realSize != null) {
          this.upsize(options.realSize);
        }
        if (options.center != null) {
          this.setCenter(options.center);
        }
        if (options.anchor != null) {
          this.setAnchor(options.anchor);
        }
        if (options.scale != null) {
          this.zoom(options.scale);
        }
        if (options.rotation != null) {
          this.rotate(options.rotation);
        }
        if (options.alpha != null) {
          this.setAlpha(options.alpha);
        }
        if (options.shadow != null) {
          this.setShadow(options.shadow);
        }
        return this.needAnimation = true;
      }

      
      // показать объект

      show() {
        this.visible = true;
        this.needAnimation = true;
        return true;
      }

      
      // скрыть объект

      hide() {
        this.visible = false;
        this.needAnimation = true;
        return false;
      }

      
      // изменить позицию объекта

      move(value1, value2) {
        this.position = this.pixel(value1, value2);
        this.needAnimation = true;
        return this.position;
      }

      
      // сдвигаем объект на нужную величину по осям

      shift(value1, value2 = 0) {
        return this.move([value1 + this.position[0], value2 + this.position[1]]);
      }

      
      // изменить размер объекта

      resize(value1, value2) {
        this.size = this.pixel(value1, value2);
        this.setAnchor(this.anchor);
        this.needAnimation = true;
        return this.size;
      }

      
      // обновить реальные размеры объекта

      upsize(value1, value2) {
        this.realSize = this.pixel(value1, value2);
        this.setAnchor(this.anchor);
        return this.realSize;
      }

      
      // установить новый центр объекта

      setCenter(value1, value2) {
        var anchorX, anchorY, size;
        this.center = this.pixel(value1, value2);
        size = this.size[0] === 0 && this.size[1] === 0 ? this.realSize : this.size;
        anchorX = size[0] === 0 ? 0 : this.center[0] / size[0];
        anchorY = size[1] === 0 ? 0 : this.center[1] / size[1];
        this.anchor = [anchorX, anchorY];
        this.needAnimation = true;
        return this.center;
      }

      
      // установить новый якорь объекта

      setAnchor(value1, value2) {
        var size;
        this.anchor = this.point(value1, value2);
        size = this.size[0] === 0 && this.size[1] === 0 ? this.realSize : this.size;
        this.center = [this.int(size[0] * this.anchor[0]), this.int(size[1] * this.anchor[1])];
        this.needAnimation = true;
        return this.anchor;
      }

      
      // установить масштаб объекта

      zoom(value1, value2) {
        this.scale = value1 != null ? this.point(value1, value2) : [1, 1];
        this.needAnimation = true;
        return this.scale;
      }

      
      // установить угол поворота объекта

      rotate(value) {
        this.rotation = this.int(value);
        if (this.rotation < 0) {
          this.rotation = 360 + this.rotation;
        }
        if (this.rotation >= 360) {
          this.rotation = this.rotation % 360;
        }
        this._rotation = this.rotation * this._PIDIV180;
        this.needAnimation = true;
        return this.rotation;
      }

      
      // повернуть объект на угол относительно текщего

      rotateOn(value) {
        return this.rotate(this.rotation + this.int(value));
      }

      
      // установить прозрачность объекта

      setAlpha(value) {
        this.alpha = value ? this.number(value) : 1;
        if (this.alpha < 0) {
          this.alpha = 0;
        }
        if (this.alpha > 1) {
          this.alpha = 1;
        }
        this.needAnimation = true;
        return this.alpha;
      }

      
      // установить тень объекта

      setShadow(value) {
        if ((value == null) || (!value)) {
          this.shadow = false;
        } else {
          this.shadow = {
            
            // не проверяем значения color и blur, потому что по умолчанию они отличны от 0

            color: value.color || "#000",
            blur: value.blur || 3,
            offsetX: this.int(value.offsetX),
            offsetY: this.int(value.offsetY),
            offset: this.int(value.offset)
          };
        }
        this.needAnimation = true;
        return this.shadow;
      }

      
      // проверяем, пуста ли точка с данными координатами

      // ВНИМАНИЕ!
      // использовать этот метод ЛОКАЛЬНО нужно осторожно, так как
      // в браузерах на основе chrome будет возникать ошибка безопасности
      // (как будто пытаешься загрузить изображение с другого хоста).
      // При загрузке кода на сервер работает во всех браузерах.

      testPoint(pointX, pointY) {
        var imageData, offsetX, offsetY, pixelData, rect;
        
        // получаем координаты канваса в окне

        rect = this.canvas.getBoundingClientRect();
        // получаем координаты точки на канвасе, относительно самого канваса
        // т.е. без учета родителей,
        // считая началом координат левый верхний угол канваса
        offsetX = pointX - rect.left;
        offsetY = pointY - rect.top;
        // данные пикселя
        imageData = this.context.getImageData(offsetX, offsetY, 1, 1);
        // цвет пикселя
        pixelData = imageData.data;
        if (pixelData.every == null) {
          // проверяем нужный метод?
          pixelData.every = Array.prototype.every;
        }
        // проверяем все цвета, если 0, значит мимо
        return !pixelData.every(function(value) {
          return value === 0;
        });
      }

      
      // находится ли точка внутри объекта по его позиции / размерам

      testRect(pointX, pointY) {
        var rect;
        rect = this.canvas.getBoundingClientRect();
        
        // если это НЕ сцена

        if (this.type !== "scene") {
          
          // корректируем позицией и размерами объекта

          rect = {
            left: rect.left + this.position[0],
            top: rect.top + this.position[1],
            right: rect.left + this.position[0] + this.size[0],
            bottom: rect.top + this.position[1] + this.size[1]
          };
        }
        
        // собственно сравнение координат

        return (pointX >= rect.left) && (pointX <= rect.right) && (pointY >= rect.top) && (pointY <= rect.bottom);
      }

      
      // анимация объекта, запускается автоматически,
      // делать вручную это не нужно

      animate() {
        // смещение
        this._deltaX = this.position[0];
        this._deltaY = this.position[1];
        // установка тени
        if (this.shadow) {
          this.context.shadowColor = this.shadow.color;
          this.context.shadowBlur = this.shadow.blur;
          this.context.shadowOffsetX = Math.max(this.shadow.offsetX, this.shadow.offset);
          this.context.shadowOffsetY = Math.max(this.shadow.offsetY, this.shadow.offset);
        }
        if (this.scale[0] !== 1 || this.scale[1] !== 1) {
          this.context.scale(this.scale[0], this.scale[1]);
        }
        if (this.alpha !== 1) {
          this.context.globalAlpha = this.alpha;
        }
        // смещение и поворот холста
        if (this.rotation !== 0) {
          this.context.translate(this.center[0] + this.position[0], this.center[1] + this.position[1]);
          this.context.rotate(this._rotation);
          this._deltaX = -this.center[0];
          this._deltaY = -this.center[1];
        }
        
        // анимация больше не нужна

        return this.needAnimation = false;
      }

      
      // Создание и установка свойств объекта

      _setProperties(options) {
        
        // Ниже идут свойтсва объекта

        // видимость объекта, устанавливаемая пользователем
        // true / false

        this.visible = options.visible != null ? options.visible : true;
        if (this.visible) {
          this.show();
        } else {
          this.hide();
        }
        
        // позиция объекта
        // массив вида [x, y]

        this.move(options.position);
        
        // реальный размер объекта,
        // может отличаться от заданного пользователем, например
        // в случае загрузки картинки

        // пока не рассчитан программно, считается равным [0, 0]

        // массив вида [width, height]

        this.realSize = [0, 0];
        
        // размер объекта
        // массив вида [width, height]

        this.resize(options.size);
        if ((options.center != null) || (options.anchor == null)) {
          
          // координаты точки, являющейся центром объекта,
          // вокруг этой точки производится вращение объекта
          // координаты точки задаются не относительно начала координат,
          // а относительно левого верхнего угла объекта
          // массив вида [x, y], либо объект вида {x: int, y: int}

          this.setCenter(options.center);
        }
        if ((options.anchor != null) && (options.center == null)) {
          
          // Якорь, дробное число, показывающее, где должен находиться цент относительно размеров объекта,
          // т.е. center = size * anchor
          // массив [number, number]

          this.setAnchor(options.anchor);
        }
        
        // Свойство хранит коэффициенты для масштабирования объектов
        // массив вида [x, y]

        this.zoom(options.scale);
        
        // поворот объекта вокруг точки center по часовой стрелке, измеряется в градусах
        // число

        this.rotate(options.rotation);
        
        // прозрачность объекта
        // число от 0 до 1

        this.setAlpha(options.alpha);
        
        // тень объекта
        // объект вида {color: string, blur: int, offsetX: int, offsetY: int, offset: int} или false
        // не нужно указывать одновременно offsetX, offsetY и offset
        // offset указывается вместо offsetX и offsetY, если offsetX == offsetY

        // ВНИМАНИЕ!
        // В браузере firefox есть баг (на 25.04.17), а именно:
        // при попытке нарисовать на канве изображение, используя одновременно
        // маску и тень (mask и shadow в данном случае), получается
        // странная хрень, а точнее маска НЕ работает в данном случае
        // Доказательство и пример здесь: http://codepen.io/cnupm99/pen/wdGKBO

        this.setShadow(options.shadow);
        
        // считаем, что надо нарисовать объект, если не указано иного

        return this.needAnimation = true;
      }

    };
    ContainerObject = class ContainerObject extends DisplayObject {
      
      // свойства:

      //  childrens:Array - массив дочерних объектов

      // методы:

      //  get(childName:String):Object/false - поиск среди дочерних элементов по имени элемента
      //  remove(childName:String):Boolean - удаление дочернего элемента по его имени
      //  rename(oldName, newName:String):Boolean - переименование дочернего элемента
      //  index(childName:String):int - возвращает индекс элемента в массиве дочерних по его имени

      constructor(options) {
        super(options);
        
        // массив дочерних элементов,
        // для CanvasEngine это Scene
        // для Scene остальные элементы
        // для остальных элементов - массив пустой
        // свойство ТОЛЬКО ДЛЯ ЧТЕНИЯ

        this.childrens = [];
      }

      
      // поиск среди дочерних элементов по имени элемента

      get(childName) {
        var index;
        index = this.index(childName);
        if (index === -1) {
          return false;
        }
        return this.childrens[index];
      }

      
      // удаление дочернего элемента по его имени

      remove(childName) {
        var index;
        index = this.index(childName);
        if (index === -1) {
          return false;
        }
        this.childrens.splice(index, 1);
        this.needAnimation = true;
        return true;
      }

      
      // переименование дочернего элемента

      rename(oldName, newName) {
        var index;
        index = this.index(oldName);
        if (index === -1) {
          return false;
        }
        this.childrens[index].name = newName;
        return true;
      }

      
      // возвращает индекс элемента в массиве дочерних по его имени

      index(childName) {
        var result;
        result = -1;
        this.childrens.some(function(child, index) {
          var flag;
          flag = child.name === childName;
          if (flag) {
            result = index;
          }
          return flag;
        });
        return result;
      }

    };
    
    // Класс для рисования графических примитивов

    // методы:

    //  clear() - очистка экрана и команд
    //  beginPath() - начало отрисовки линии
    //  lineCap(value:String) - установить стиль окончания линий
    //  strokeStyle(style:String) - стиль линий
    //  fillStyle(style:String) - стиль заливки
    //  linearGradient(x1, y1, x2, y2:int, colors:Array) - установка градиента
    //  lineWidth(value:int) - толщина линий
    //  setLineDash(value:Array) - установка пунктирной линии
    //  lineDashOffset(value:int) - смещение пунктирной линии
    //  moveTo(x, y:int) - перемещение указателя
    //  lineTo(x, y:int) - линия в указанную точку
    //  line(x1, y1, x2, y2:int) - рисуем линию по двум точкам
    //  rect(x, y, width, height, radius:int) - рисуем прямоугольник (опционально скругленный)
    //  circle(x, y, radius:int) - рисуем круг
    //  arc(x, y, radius:int, beginAngle, endAngle:number, antiClockWise:Boolean) - нарисовать дугу
    //  polyline(points:Array, needDraw:Boolean) - полилиния
    //  polygon(points:Array) - полигон
    //  fill() - заливка фигуры
    //  stroke() - прорисовка контура
    //  animate() - попытка нарисовать объект
    //  log() - выводим массив комманд в консоль

    Graph = class Graph extends DisplayObject {
      constructor(options) {
        super(options);
        
        // тип объекта

        this.type = "graph";
        // массив команд для рисования
        this._commands = [];
      }

      
      // Далее идут функции для рисования графических примитивов
      // Все они сохраняют свои данные в _commands

      // очистка экрана и команд

      clear() {
        this._commands = [];
        return this.needAnimation = true;
      }

      
      // начало отрисовки линии

      beginPath() {
        return this._commands.push({
          "command": "beginPath"
        });
      }

      
      // установить стиль окончания линий

      lineCap(value) {
        return this._commands.push({
          "command": "lineCap",
          "lineCap": value
        });
      }

      
      // стиль линий

      strokeStyle(style) {
        return this._commands.push({
          "command": "strokeStyle",
          "style": style
        });
      }

      
      // стиль заливки

      fillStyle(style) {
        return this._commands.push({
          "command": "fillStyle",
          "style": style
        });
      }

      
      // устновка градиента
      // colors = Array [ [size, color], .... ], где color:String, size:Number [0..1]

      linearGradient(x1, y1, x2, y2, colors) {
        return this._commands.push({
          "command": "gradient",
          "point1": this.pixel(x1, y1),
          "point2": this.pixel(x2, y2),
          "colors": colors
        });
      }

      
      // толщина линий

      lineWidth(width) {
        return this._commands.push({
          "command": "lineWidth",
          "width": this.int(width)
        });
      }

      
      // установка пунктирной линии

      setLineDash(dash) {
        return this._commands.push({
          "command": "setDash",
          "dash": dash
        });
      }

      
      // смещение пунктирной линии

      lineDashOffset(offset) {
        return this._commands.push({
          "command": "dashOffset",
          "offset": this.int(offset)
        });
      }

      
      // Перевод указателя в точку

      moveTo(toX, toY) {
        return this._commands.push({
          "command": "moveTo",
          "point": this.pixel(toX, toY)
        });
      }

      
      // Линия из текущей точки в указанную

      lineTo(toX, toY) {
        this._commands.push({
          "command": "lineTo",
          "point": this.pixel(toX, toY)
        });
        return this.needAnimation = true;
      }

      
      // рисуем линию, соединяющую две точки,
      // разница между moveTo + lineTo еще и в том, что line рисует линию,
      // т.е. автоматически делает stroke()

      line(fromX, fromY, toX, toY) {
        this._commands.push({
          "command": "line",
          "from": this.pixel(fromX, fromY),
          "to": this.pixel(toX, toY)
        });
        return this.needAnimation = true;
      }

      
      // рисуем прямоугольник, если указан radius, то скругляем углы

      rect(fromX, fromY, width, height, radius = 0) {
        this._commands.push({
          "command": "rect",
          "point": this.pixel(fromX, fromY),
          "size": this.pixel(width, height),
          "radius": this.int(radius)
        });
        return this.needAnimation = true;
      }

      
      // рисуем круг

      circle(centerX, centerY, radius) {
        this._commands.push({
          "command": "circle",
          "center": this.pixel(centerX, centerY),
          "radius": this.int(radius)
        });
        return this.needAnimation = true;
      }

      
      // рисуем дугу

      arc(centerX, centerY, radius, beginAngle, endAngle, antiClockWise) {
        this._commands.push({
          "command": "arc",
          "center": this.pixel(centerX, centerY),
          "radius": this.int(radius),
          "beginAngle": this.deg2rad(beginAngle),
          "endAngle": this.deg2rad(endAngle),
          "antiClockWise": antiClockWise || false
        });
        return this.needAnimation = true;
      }

      
      // линия из множества точек
      // второй параметр говорит, нужно ли ее рисовать,
      // он нужен, чтобы рисовать многоугольники без границы

      polyline(points, stroke = true) {
        this._commands.push({
          "command": "beginPath"
        });
        this.moveTo(points[0][0], points[0][1]);
        points.forEach((point) => {
          return this.lineTo(point[0], point[1]);
        });
        if (stroke) {
          this.stroke();
        }
        return this.needAnimation = true;
      }

      
      // полигон

      polygon(points) {
        this.polyline(points, false);
        this.lineTo(points[0][0], points[0][1]);
        this.stroke();
        return this.fill();
      }

      
      // Заливка

      fill() {
        this._commands.push({
          "command": "fill"
        });
        return this.needAnimation = true;
      }

      
      // Рисуем контур

      stroke() {
        this._commands.push({
          "command": "stroke"
        });
        return this.needAnimation = true;
      }

      animate() {
        
        // если объект не видимый
        // то рисовать его не нужно

        if (!this.visible) {
          this.needAnimation = false;
          return;
        }
        super.animate();
        
        // установим закругленные окончания линий

        this.context.lineCap = "round";
        
        // перебираем все команды в массиве команд и выполняем соответствующие действия
        // можно было поменять строковые команды на числа вида 0, 1, 2 .... и т.д.,
        // но зачем?

        return this._commands.forEach((command) => {
          var gradient;
          switch (command.command) {
            case "beginPath":
              return this.context.beginPath();
            case "lineCap":
              return this.context.lineCap = command.lineCap;
            case "stroke":
              return this.context.stroke();
            case "fill":
              return this.context.fill();
            case "setDash":
              return this.context.setLineDash(command.dash);
            case "dashOffset":
              return this.context.lineDashOffset = command.offset;
            case "moveTo":
              return this.context.moveTo(command.point[0] + this._deltaX, command.point[1] + this._deltaY);
            case "lineTo":
              return this.context.lineTo(command.point[0] + this._deltaX, command.point[1] + this._deltaY);
            case "line":
              this.context.beginPath();
              this.context.moveTo(command.from[0] + this._deltaX, command.from[1] + this._deltaY);
              this.context.lineTo(command.to[0] + this._deltaX, command.to[1] + this._deltaY);
              return this.context.stroke();
            case "strokeStyle":
              return this.context.strokeStyle = command.style;
            case "fillStyle":
              return this.context.fillStyle = command.style;
            case "lineWidth":
              return this.context.lineWidth = command.width;
            case "rect":
              this.context.beginPath();
              
              // обычный прямоугольник
              if (command.radius === 0) {
                return this.context.rect(command.point[0] + this._deltaX, command.point[1] + this._deltaY, command.size[0], command.size[1]);
              } else {
                // прямоугольник со скругленными углами
                return this._drawRoundedRect(this.context, command.point[0] + this._deltaX, command.point[1] + this._deltaY, command.size[0], command.size[1], command.radius);
              }
              break;
            case "circle":
              this.context.beginPath();
              return this.context.arc(command.center[0] + this._deltaX, command.center[1] + this._deltaY, command.radius, 0, 2 * Math.PI, false);
            case "arc":
              this.context.beginPath();
              return this.context.arc(command.center[0] + this._deltaX, command.center[1] + this._deltaY, command.radius, command.beginAngle, command.endAngle, command.antiClockWise);
            case "gradient":
              // создаем градиент по нужным точкам
              gradient = this.context.createLinearGradient(command.point1[0] + this._deltaX, command.point1[1] + this._deltaY, command.point2[0] + this._deltaX, command.point2[1] + this._deltaY);
              // добавляем цвета
              command.colors.forEach(function(color) {
                // сначала размер, потом цвет
                return gradient.addColorStop(color[0], color[1]);
              });
              // заливка градиентом
              return this.context.fillStyle = gradient;
          }
        });
      }

      
      // В информационных целях
      // выводим массив комманд в консоль

      log() {
        return console.log(this._commands);
      }

      
      // рисуем пряоугольник со скругленными углами

      _drawRoundedRect(context, x, y, width, height, radius) {
        var halfpi, pi, x1, x2, y1, y2;
        // предварительные вычисления
        pi = Math.PI;
        halfpi = pi / 2;
        x1 = x + radius;
        x2 = x + width - radius;
        y1 = y + radius;
        y2 = y + height - radius;
        // рисуем
        context.moveTo(x1, y);
        context.lineTo(x2, y);
        context.arc(x2, y1, radius, -halfpi, 0);
        context.lineTo(x + width, y2);
        context.arc(x2, y2, radius, 0, halfpi);
        context.lineTo(x1, y + height);
        context.arc(x1, y2, radius, halfpi, pi);
        context.lineTo(x, y1);
        return context.arc(x1, y1, radius, pi, 3 * halfpi);
      }

    };
    Image = class Image extends DisplayObject {
      
      // Класс для загрузки и отображения изображений

      // свойства:

      //  onload:Function - ссылка на функцию, которая должна выполниться после загрузки картинки
      //  loaded:Boolean - загружена ли картинка
      //  image:Image - объект картинки
      //  loadedFrom:String - строка с адресом картинки
      //  rect:Array - прямоугольник для отображения части картинки

      // методы:

      //  src(url:string): загрузка картинки с указанным адресом
      //  from(image:Image, url:String) - создание из уже существующей и загруженной картинки
      //  setRect(rect:Array):Array - установка области для отображения только части картинки
      //  animate() - попытка нарисовать объект

      constructor(options) {
        super(options);
        this._imageOnLoad = this._imageOnLoad.bind(this);
        
        // тип объекта

        this.type = "image";
        
        // событие, выполняемое при загрузке картинки

        this.onload = options.onload;
        
        // Загружена ли картинка,
        // в данный момент нет,
        // а значит рисовать ее не нужно

        this.loaded = false;
        
        // создаем элемент

        this.image = document.createElement("img");
        
        // Событие при загрузке картинки

        this.image.onload = this._imageOnLoad;
        
        // Здесь будем хранить src картинки как строку.
        // При вызове src картика загружается, а адрес устанавливается в loadedFrom
        // При присвоении loadedFrom картинка не загружается
        // Это просто строка для хранения адреса картинки

        this.loadedFrom = "";
        
        // свойство для отображения только части картинки

        this.setRect(options.rect);
        
        // нужно ли загружать картинку

        if (options.src != null) {
          this.src(options.src);
        } else {
          
          // или она уже загружена

          this.from(options.from);
        }
      }

      
      // Установка области

      setRect(value) {
        this.rect = value || false;
        this.needAnimation = true;
        return this.rect;
      }

      
      // Метод для загрузки картики

      src(value) {
        this.loaded = false;
        this.loadedFrom = value;
        // загружаем
        return this.image.src = value;
      }

      
      // Создание картинки из уже созданной и загруженной

      // 	image: Image
      // 	src: String // не обязательно

      from(from, src) {
        
        // если картинки нет, то нет смысла продолжать

        if (from == null) {
          return;
        }
        
        // а вот и картинка

        this.image = from;
        
        // Запоминаем src

        this.loadedFrom = src || "";
        
        // запоминаем реальные размеры

        this.upsize([this.image.width, this.image.height]);
        if (this.size[0] <= 0 || this.size[1] <= 0) {
          
          // если нужно меняем размеры
          // иначе потом будем масштабировать

          this.resize(this.realSize);
        }
        // можно рисовать
        this.loaded = true;
        return this.needAnimation = true;
      }

      animate() {
        
        // если картинка не загружена, то рисовать ее не будем

        if (!this.loaded) {
          return;
        }
        
        // если объект не видимый
        // то рисовать его не нужно

        if (!this.visible) {
          this.needAnimation = false;
          return;
        }
        
        // действия по умолчанию для DisplayObject

        super.animate();
        
        // если нужно рисовать определенную область изображения

        if (this.rect) {
          
          // вырезаем и рисуем в нужном масштабе определенную область картинки

          return this.context.drawImage(this.image, this.rect[0], this.rect[1], this.rect[2], this.rect[3], this._deltaX, this._deltaY, this.size[0], this.size[1]);
        } else {
          
          // рисуем в реальном размере?

          if (this.size[0] === this.realSize[0] && this.size[1] === this.realSize[1]) {
            return this.context.drawImage(this.image, this._deltaX, this._deltaY);
          } else {
            
            // тут просто масштабируем картинку

            return this.context.drawImage(this.image, this._deltaX, this._deltaY, this.size[0], this.size[1]);
          }
        }
      }

      _imageOnLoad(e) {
        boundMethodCheck(this, Image);
        
        // запоминаем реальные размеры

        this.upsize([this.image.width, this.image.height]);
        if (this.size[0] <= 0 || this.size[1] <= 0) {
          
          // если нужно меняем размеры
          // иначе потом будем масштабировать

          this.resize(this.realSize);
        }
        this.loaded = true;
        this.needAnimation = true;
        if (this.onload != null) {
          
          // если у картинки есть свойство onload, то вызываем его и
          // сообщаем реальные размеры картинки

          return this.onload(this.realSize);
        }
      }

    };
    
    // Класс для вывода текстовой информации

    // свойства:

    //  fontHeight:int - высота шрифта
    //  textWidth:int - ширина текущего текста
    //  textHeight:int - высота текущего текста
    //  realSize:Array - размеры области текущего текста с учетом шрифта и многострочности
    //  font:String - текущий шрифт
    //  fillStyle:String/Array/Boolean - текущая заливка, градиент или false, если заливка не нужна
    //  strokeStyle:String/Boolean - обводка шрифта или false, если обводка не нужна
    //  strokeWidth:int - ширина обводки
    //  underline:Boolean - подчеркнутый текст
    //  underlineOffset:int - смещение линии подчеркивания
    //  text:String - отображаемый текст

    // методы:

    //  setFont(font:String):String - установка шрифта
    //  setFillStyle(style:String/Array):String/Array - установка заливки текста
    //  setStrokeStyle(style:String):String - установка обводки
    //  setStrokeWidth(value:int):int - толщина обводки
    //  setUnderline(value:Boolean, offset:int):Boolean - установка подчеркивания текста
    //  write(text:String):String - установка текста
    //  animate() - попытка нарисовать объект

    Text = class Text extends DisplayObject {
      constructor(options) {
        super(options);
        
        // тип объекта

        this.type = "text";
        
        // высота текста с текущим шрифтом,
        // вычисляется автоматичекски при установке шрифта

        this.fontHeight = 0;
        
        // ширина текущего текста
        // вычисляется автоматически при установке текста

        this.textWidth = 0;
        
        // шрифт надписи, строка

        this.setFont(options.font);
        
        // текущая заливка, градиент или false, если заливка не нужна

        this.setFillStyle(options.fillStyle);
        
        // обводка шрифта или false, если обводка не нужна

        this.setStrokeStyle(options.strokeStyle);
        
        // ширина обводки

        this.setStrokeWidth(options.strokeWidth);
        
        // установка подчеркнутого текста

        this.setUnderline(options.underline, options.underlineOffset);
        
        // текущий текст надписи

        this.write(options.text);
      }

      setFont(value) {
        
        // установка шрифта

        this.font = value || "12px Arial";
        
        // получаем высоту шрифта

        this.fontHeight = this._getFontHeight(this.font);
        this.needAnimation = true;
        return this.font;
      }

      setFillStyle(value) {
        this.fillStyle = value || false;
        this.needAnimation = true;
        return this.fillStyle;
      }

      setStrokeStyle(value) {
        this.strokeStyle = value || false;
        this.needAnimation = true;
        return this.strokeStyle;
      }

      setStrokeWidth(value) {
        this.strokeWidth = value != null ? this.int(value) : 1;
        this.needAnimation = true;
        return this.strokeWidth;
      }

      setUnderline(value, offset) {
        this.underline = value || false;
        this.underlineOffset = offset || 0;
        this.needAnimation = true;
        return this.underline;
      }

      write(value) {
        
        // установка текста

        this.text = value || "";
        
        // получаем реальные размеры области с текстом
        // с учетом многострочности и установленного шрифта

        this.upsize(this._getRealSizes(this.text));
        
        // вспомогательные свойства, нужны для удобства
        // и обратной совметсимости

        this.textWidth = this.realSize[0];
        this.textHeight = this.realSize[1];
        this.needAnimation = true;
        return this.text;
      }

      animate() {
        var fontSize, gradient, lines, textY, underlineStyle;
        
        // если объект не видимый
        // то рисовать его не нужно

        if (!this.visible) {
          this.needAnimation = false;
          return;
        }
        super.animate();
        
        // установим шрифт контекста

        this.context.font = this.font;
        
        // по умолчанию позиционируем текст по верхнему краю

        this.context.textBaseline = "top";
        
        // нужна ли заливка

        if (this.fillStyle) {
          // а может зальем текст градиентом?
          if (Array.isArray(this.fillStyle)) {
            
            // создаем градиент по нужным точкам

            gradient = this.context.createLinearGradient(this._deltaX, this._deltaY, this._deltaX, this._deltaY + this.fontHeight);
            
            // добавляем цвета

            this.fillStyle.forEach(function(color) {
              
              // сначала размер, потом цвет
              return gradient.addColorStop(color[0], color[1]);
            });
            
            // заливка градиентом

            this.context.fillStyle = gradient;
          } else {
            
            // ну или просто цветом

            this.context.fillStyle = this.fillStyle;
          }
        }
        
        // что насчет обводки?

        if (this.strokeStyle) {
          this.context.strokeStyle = this.strokeStyle;
          this.context.lineWidth = this.strokeWidth;
        }
        
        // разбиваем текст на строки, это нужно для вывода многострочного текста

        lines = this.text.split("\n");
        
        // координата для смещения текста по вертикали

        textY = this._deltaY;
        
        // если нужно подчеркивание текста

        if (this.underline) {
          
          // парсим шрифт в надежде найти размер шрифта
          // используем его для рисования подчеркивание
          // это ближе к истене чем использование fontHeight

          fontSize = parseInt(this.font, 10);
          
          // стиль линии подчеркивания

          underlineStyle = this.strokeStyle || this.fillStyle;
        }
        
        // выводим текст построчно

        return lines.forEach((line) => {
          var lineWidth;
          if (this.fillStyle) {
            
            // вывод текста

            this.context.fillText(line, this._deltaX, textY);
          }
          if (this.strokeStyle) {
            this.context.strokeText(line, this._deltaX, textY);
          }
          
          // рисуем подчеркивание

          if (this.underline) {
            
            // длина данной строки текста

            lineWidth = this._getTextWidth(line);
            
            // стиль линии

            this.context.strokeStyle = underlineStyle;
            this.context.lineWidth = this.strokeWidth || 1;
            
            // линия

            this.context.beginPath();
            this.context.moveTo(this._deltaX, textY + fontSize + this.underlineOffset);
            this.context.lineTo(this._deltaX + lineWidth, textY + fontSize + this.underlineOffset);
            this.context.stroke();
          }
          
          // смещение следующей строки

          return textY += this.fontHeight;
        });
      }

      
      // устанавливаем реальную высоту шрифта в пикселях

      _getFontHeight(font) {
        var fontHeight, span;
        span = document.createElement("span");
        span.appendChild(document.createTextNode("height"));
        span.style.cssText = "font: " + font + "; white-space: nowrap; display: inline;";
        document.body.appendChild(span);
        fontHeight = span.offsetHeight;
        document.body.removeChild(span);
        return fontHeight;
      }

      
      // определяем ширину текста
      // используя для этого ссылку на контекст

      _getTextWidth(text) {
        var textWidth;
        this.context.save();
        this.context.font = this.font;
        textWidth = this.context.measureText(text).width;
        this.context.restore();
        return textWidth;
      }

      
      // получаем реальные размеры области текста

      _getRealSizes(text) {
        var lines, maxWidth;
        
        // начальное значение максимальной ширины строки

        maxWidth = 0;
        
        // разбиваем текст на строки, это нужно для вывода многострочного текста

        lines = this.text.split("\n");
        
        // проверяем ширину каждой строки,
        // если нужно обновляем максимальное значение

        lines.forEach((line) => {
          var width;
          width = this._getTextWidth(line);
          if (width > maxWidth) {
            return maxWidth = width;
          }
        });
        
        // итоговый результат,
        // максимальная ширина,
        // высота равна количеству строк на высоту одной строки

        return [maxWidth, lines.length * this.fontHeight];
      }

    };
    
    // Изображение, которое замостит указанную область

    // свойства:

    //  rect:Array - прямоугольник для замастивания

    // методы:

    //  setRect(value:Array):Array - установка области
    //  animate() - попытка нарисовать объект 

    TilingImage = class TilingImage extends Image {
      constructor(options) {
        super(options);
        
        // тип объекта

        this.type = "tile";
        
        // область замостивания по умолчанию равна размеру контекста

        // массив вида [int, int, int, int]

        this.setRect(options.rect);
      }

      
      // Установка области

      setRect(value) {
        this.rect = value || [0, 0, this.canvas.width, this.canvas.height];
        this.needAnimation = true;
        return this.rect;
      }

      animate() {
        if (!this.loaded) {
          return;
        }
        
        // если объект не видимый
        // то рисовать его не нужно

        if (!this.visible) {
          this.needAnimation = false;
          return;
        }
        
        // Начало отрисовки

        this.context.beginPath();
        
        // создаем паттерн

        this.context.fillStyle = this.context.createPattern(this.image, "repeat");
        
        // рисуем прямоугольник

        this.context.rect(this.rect[0], this.rect[1], this.rect[2], this.rect[3]);
        
        // заливаем паттерном

        this.context.fill();
        
        // анимация больше не нужна

        return this.needAnimation = false;
      }

    };
    Scene = class Scene extends ContainerObject {
      
      // Класс сцены, на который добавляются все дочерние объекты
      // Фактически представляет собой canvas

      // свойства:

      //  canvas:Element - canvas для рисования, создается автоматически
      //  context:context2d - контекст для рисования, создается автоматически
      //  zIndex:int - индекс, определяющий порядок сцен, чем выше индекс, тем выше сцена над остальными
      //  mask:Array - маска объекта
      //  needAnimation:Boolean - нужно ли анимировать данный объект с точки зрения движка

      // методы:

      //  add(data:Object):DisplayObject - добавление дочернего объекта
      //  clear() - полная очистка сцены
      //  animate() - попытка нарисовать объект

      // установка свойств:

      //  setMask(value:Object):Object - установка маски
      //  setZIndex(value:int):int - установка зед индекса канваса
      //  hide() - скрыть сцену
      //  move(value1, value2:int):Array - изменить позицию канваса
      //  shiftAll(value1, value2:int) - сдвигаем все дочерные объекты
      //  resize(value1, value2:int):Array - изменить размер канваса
      //  setCenter(value1, value2:int):Array - установить новый центр канваса
      //  setAnchor(value1, value2:int):Array - установить якорь канваса
      //  rotate(value:int):int - установить угол поворота канваса
      //  setAlpha(value:Number):Number - установить прозрачность канваса

      constructor(options) {
        
        // создаем DisplayObject

        super(options);
        
        // тип объекта

        this.type = "scene";
        
        // индекс, определяющий порядок сцен, чем выше индекс, тем выше сцена над остальными
        // целое число >= 0

        this.setZIndex(options.zIndex);
        
        // прямоугольная маска, применимо к Scene
        // если маска дейтсвует, то на сцене будет отображаться только объекты внутри маски
        // массив [int, int, int, int] или false

        // ВНИМАНИЕ!
        // В браузере firefox есть баг (на 25.04.17), а именно:
        // при попытке нарисовать на канве изображение, используя одновременно
        // маску и тень (mask и shadow в данном случае), получается
        // странная хрень, а точнее маска НЕ работает в данном случае
        // Доказательство и пример здесь: http://codepen.io/cnupm99/pen/wdGKBO

        this.setMask(options.mask);
        
        // нужно ли анимировать данный объект с точки зрения движка
        // не нужно в ручную менять это свойство, для этого есть visible

        this.needAnimation = false;
      }

      
      // создание и добавление дочерних объектов в список анимации

      add(options) {
        var result;
        
        // нет типа - нечего создавать

        if (options.type == null) {
          return;
        }
        if (options.visible == null) {
          
          // если нужно, задаем значения по умолчанию

          options.visible = this.visible;
        }
        if (options.shadow == null) {
          options.shadow = this.shadow;
        }
        
        // передаем канвас и контекст для рисования

        options.canvas = this.canvas;
        options.context = this.context;
        
        // создание объекта

        switch (options.type) {
          case "image":
            result = new Image(options);
            break;
          case "text":
            result = new Text(options);
            break;
          case "graph":
            result = new Graph(options);
            break;
          case "tile":
            result = new TilingImage(options);
        }
        
        // добавляем в список дочерних объектов

        this.childrens.push(result);
        
        // возвращаем результат

        return result;
      }

      
      // очистка сцены

      clear() {
        
        // удаляем все дочерние элементы

        this.childrens = [];
        
        // перерисовка

        return this.needAnimation = true;
      }

      
      // Установка прямоугольной маски для рисования

      setMask(value) {
        if ((value == null) || (!value)) {
          this.mask = false;
        } else {
          this.mask = value;
        }
        this.needAnimation = true;
        return this.mask;
      }

      
      // Установка zIndex

      setZIndex(value) {
        this.zIndex = this.int(value);
        this.canvas.style.zIndex = this.zIndex;
        return this.zIndex;
      }

      
      // Далее функции, перегружающие свойсва экранного объекта,
      // т.к. нам нужно в этом случае двигать, поворачивать и т.д. сам канвас

      hide() {
        super.hide();
        return this.context.clearRect(0, 0, this.size[0], this.size[1]);
      }

      move(value1, value2) {
        super.move(value1, value2);
        
        // двигаем канвас по экрану

        this.canvas.style.left = this.position[0] + "px";
        this.canvas.style.top = this.position[1] + "px";
        return this.position;
      }

      
      // сдвигаем все дочерние объекты

      shiftAll(value1, value2 = 0) {
        return this.childrens.forEach(function(child) {
          return child.shift(value1, value2);
        });
      }

      resize(value1, value2) {
        super.resize(value1, value2);
        
        // меняем размер канваса

        this.canvas.width = this.size[0];
        this.canvas.height = this.size[1];
        return this.size;
      }

      setCenter(value1, value2) {
        super.setCenter(value1, value2);
        
        // сдвигаем начало координат в центр

        this.context.translate(this.center[0], this.center[1]);
        return this.center;
      }

      setAnchor(value1, value2) {
        super.setAnchor(value1, value2);
        
        // сдвигаем начало координат в центр

        this.context.translate(this.center[0], this.center[1]);
        return this.anchor;
      }

      rotate(value) {
        super.rotate(value);
        
        // поворот всего контекста на угол

        this.context.rotate(this._rotation);
        return this.rotation;
      }

      setAlpha(value) {
        super.setAlpha(value);
        this.context.globalAlpha = this.alpha;
        return this.alpha;
      }

      
      // анимация сцены

      animate() {
        
        // если объект не видимый
        // то рисовать его не нужно

        if (!this.visible) {
          this.needAnimation = false;
          return;
        }
        
        // очистка контекста

        this.context.clearRect(0, 0, this.size[0], this.size[1]);
        
        // установка маски

        if (this.mask) {
          this.context.beginPath();
          this.context.rect(this.mask[0], this.mask[1], this.mask[2], this.mask[3]);
          this.context.clip();
        }
        
        // анимация в буфер

        this.childrens.forEach((child) => {
          this.context.save();
          child.animate();
          return this.context.restore();
        });
        
        // анимация больше не нужна

        return this.needAnimation = false;
      }

    };
    
    // Движок для Canvas

    CanvasEngine = class CanvasEngine extends ContainerObject {
      
      // Главный класс, через него осуществляется взаимодействие с движком

      // свойства:

      //  parent:Element - элемент для отрисовки движка

      // методы:

      //  add(options):DisplayObject - метод для добавления новых объектов / сцен
      //  remove(childName):Boolean - удаляем сцену
      //  onTop(childName):Scene/Boolean - поднимаем сцену на верх отображения
      //  getActive():Scene/Boolean - получить активную сцену
      //  setActive(sceneName:String):Scene - установить активную сцену по имени
      //  start() - запускаем цикл анимации
      //  stop() - останавливаем цикл анимации
      //  addEvent(func) - добавить функцию, выполняемую каждый раз перед анимацией
      //  removeEvent(func) - удалить функцию из цикла анимации
      //  fullscreen(Boolean):Boolean - включить/выключить полноэкранный режим
      //  isFullscreen():Boolean - определяет, включен ли полноэкранный режим
      //  canvasSupport():Boolean - проверка, поддерживает ли браузер canvas и context

      constructor(options) {
        super(options);
        
        // цикл анимации, запускается автоматически,
        // не нужно это делать вручную,
        // для этого есть методы start() и stop()

        this._animate = this._animate.bind(this);
        
        // проверка поддержки канвас и контекст

        if (!this.canvasSupport()) {
          console.log("your browser not support canvas and/or context");
          return false;
        }
        
        // элемент для отрисовки движка
        // свойство ТОЛЬКО ДЛЯ ЧТЕНИЯ

        this.parent = options.parent || document.body;
        
        // если размеры движка не заданы, то пытаемся установить их равными
        // размеру контейнера

        if (this.size[0] === 0 && this.size[1] === 0) {
          this.size = [this.int(this.parent.clientWidth), this.int(this.parent.clientHeight)];
        }
        
        // массив функций для выполнения в цикле перед анимацией

        this._beforeAnimate = [];
        
        // Свойство хранит имя активной сцены в виде строки

        this._scene = "default";
        
        // создаем сцену по умолчанию

        this.add({
          type: "scene",
          name: "default"
        });
        
        // запуск анимации

        this.start();
      }

      
      // Глобальная функция для добавления всего, что угодно

      add(options) {
        var scene, type;
        if (options == null) {
          
          // создаем пустой объект, если необходимо

          options = {};
        }
        
        // тип добавляемого объекта,
        // по умолчанию - сцена

        type = options.type || "scene";
        
        // добавить сцену?

        if (type === "scene") {
          return this._createScene(options);
        } else {
          
          // на какую сцену добавить объект?

          // добавление всего остального, кроме сцен

          scene = this.get(options.scene);
          if (!scene) {
            
            // если в опциях не указана сцена, то добавляем на активную сцену

            scene = this.getActive();
          }
          
          // если в списке нет ниодной сцены, создадим сцену по умолчанию

          if (!scene) {
            scene = this.add({
              type: "scene",
              name: "default"
            });
          }
          
          // добавляем объект на нужную сцену

          return scene.add(options);
        }
      }

      
      // удаляем сцену по ее имени
      // отдельная функция, т.к. тут нужно удалить канвас с элемента

      remove(childName) {
        var index;
        index = this.index(childName);
        if (index === -1) {
          return false;
        }
        this.parent.removeChild(this.childrens[index].canvas);
        this.childrens.splice(index, 1);
        return true;
      }

      
      // переносим сцену на верх отображения
      // для чего делаем ее zIndex на 1 больше максимального из существующих

      onTop(childName) {
        var maxZ, result;
        maxZ = 0;
        result = false;
        this.childrens.forEach(function(child) {
          if (child.zIndex > maxZ) {
            maxZ = child.zIndex;
          }
          if (childName === child.name) {
            return result = child;
          }
        });
        if (result) {
          result.setZIndex(maxZ + 1);
        }
        return result;
      }

      
      // Возвращает активную сцену

      getActive() {
        var result;
        result = this.get(this._scene);
        if (!result) {
          result = this.childrens[0];
        }
        if (!result) {
          result = false;
        }
        return result;
      }

      
      // Устанавливает активную сцену по ее имени

      setActive(sceneName) {
        this._scene = sceneName || "default";
        return this.getActive();
      }

      
      // запуск анимации

      start() {
        return this._render = requestAnimationFrame(this._animate);
      }

      
      // остановка анимации

      stop() {
        return cancelAnimationFrame(this._render);
      }

      
      // добавить функцию для выполнения в цикле
      // функции выполняются в порядке добавления
      // ПЕРЕД аниамацией

      addEvent(func) {
        return this._beforeAnimate.push(func);
      }

      
      // удаление функции из массива
      // эта функция больше не будет выполняться перед анимацией

      removeEvent(func) {
        return this._beforeAnimate.forEach((item, i) => {
          if (item === func) {
            return this._beforeAnimate.splice(i, 1);
          }
        });
      }

      
      // установить / снять полноэкранный режим
      // для элемента

      fullscreen(value, element) {
        if (value == null) {
          
          // установка значений по умолчанию

          value = true;
        }
        if (!element) {
          element = this.parent;
        }
        if (value) {
          if (element.requestFullScreen != null) {
            element.requestFullScreen();
          } else if (element.webkitRequestFullScreen != null) {
            element.webkitRequestFullScreen();
          } else if (element.mozRequestFullScreen != null) {
            element.mozRequestFullScreen();
          } else {
            return false;
          }
        } else {
          if (document.cancelFullScreen != null) {
            document.cancelFullScreen();
          } else if (document.webkitCancelFullScreen != null) {
            document.webkitCancelFullScreen();
          } else if (document.mozCancelFullScreen != null) {
            document.mozCancelFullScreen();
          } else if (document.exitFullScreen != null) {
            document.exitFullScreen();
          } else {
            return false;
          }
        }
        return true;
      }

      // проверка, находится ли документ в полноэкранном режиме
      isFullscreen() {
        var element;
        element = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement;
        return element != null;
      }

      
      // проверка, поддерживает ли браузер canvas и context

      canvasSupport() {
        return document.createElement("canvas").getContext != null;
      }

      
      // создание сцены с нужными опциями

      _createScene(options) {
        var scene;
        if (options.visible == null) {
          
          // если нужно, задаем значения по умолчанию

          options.visible = this.visible;
        }
        if (options.position == null) {
          options.position = this.position;
        }
        if (options.size == null) {
          options.size = this.size;
        }
        if (options.center == null) {
          options.center = this.center;
        }
        if (options.rotation == null) {
          options.rotation = this.rotation;
        }
        if (options.alpha == null) {
          options.alpha = this.alpha;
        }
        if (options.mask == null) {
          options.mask = this.mask;
        }
        if (options.shadow == null) {
          options.shadow = this.shadow;
        }
        
        // передаем родителя, как элемент для создания канваса

        options.parent = this.parent;
        
        // создаем сцену

        scene = new Scene(options);
        
        // добавляем в список дочерних объектов

        this.childrens.push(scene);
        
        // делаем новую сцену активной

        this.setActive(scene.name);
        return scene;
      }

      _animate() {
        boundMethodCheck(this, CanvasEngine);
        
        // выполняем все функции в массиве

        this._beforeAnimate.forEach((func, i) => {
          
          // если это функция, то выполняем ее

          if (typeof func === "function") {
            return func();
          } else {
            
            // а иначе удаляем эту чушь из массива

            return this._beforeAnimate.splice(i, 1);
          }
        });
        
        // АНИМАЦИЯ ТУТ

        // а может не надо?
        this.needAnimation = false;
        
        // перебираем сцены
        this.childrens.forEach((child) => {
          var needAnimation;
          needAnimation = child.needAnimation || child.childrens.some(function(childOfChild) {
            return childOfChild.needAnimation;
          });
          // сохраняем значение
          this.needAnimation = this.needAnimation || needAnimation;
          if (needAnimation) {
            // собственно анимация
            return child.animate();
          }
        });
        
        // продолжаем анимацию

        return this._render = requestAnimationFrame(this._animate);
      }

    };
    
    // Возвращаем результат

    return CanvasEngine;
  });

}).call(this);
