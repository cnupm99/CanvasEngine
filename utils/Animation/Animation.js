// Generated by CoffeeScript 2.0.2
(function() {
  "use strict";
  define(function() {
    var Animation;
    
    // Анимация, рисующая несколько картинок, сменяющих друг друга.

    // Варианты создания:

    // 	1. from:Array - массив картинок, сменяющих друг друга
    // 	2. src:Array - НЕ рекомендуется из-за мигания при загрузке картинок
    // 	3. frameSet:Array - массив прямоугольных координат для вырезания кадров из картинки
    // 	4. frameCount:int или frameWidth:int - количество или ширина кадров для вырезания их из картинки

    return Animation = class Animation {
      constructor(CE, options) {
        
        // собственно обработка анимации

        this.update = this.update.bind(this);
        
        // установка опций анимации

        this._setOptions(options);
        if (options.from != null) {
          
          // работаем через from

          options.from = this._setFrom(options);
        }
        if (options.src != null) {
          
          // работаем через src

          options.src = this._setSrc(options);
        }
        
        // создаем картинку

        this._createImage(options);
        if (options.frameSet != null) {
          
          // работаем через наборы кадров

          this.setFrameSet(options.frameSet);
        }
        if ((options.frameWidth != null) || (options.frameCount != null)) {
          
          // работаем через количество или ширину кадров

          this._setFrameCount(options);
        }
        
        // добавляем функцию обновления анимации

        CE.addEvent(this.update);
        if (this.autoPlay) {
          
          // автовоспроизведение

          this.play();
        }
      }

      
      // установка набора кадров

      setFrameSet(value) {
        
        // массив координат для вырезания кадров

        this.frameSet = value;
        
        // количество кадров в анимации

        this.maxFrame = this.frameSet.length - 1;
        if (this.currentFrame > this.maxFrame || this.currentFrame < 0) {
          
          // текущий кадр 

          this.currentFrame = 0;
        }
        
        // устновка кадра

        this.image.setRect(this.frameSet[this.currentFrame]);
        
        // установка типа анимации

        return this.type = "set";
      }

      
      // установка массива с картинками

      setFrames(frames) {
        
        // массив с картинками

        this.frames = frames;
        
        // количество кадров

        this.maxFrame = this.frames.length - 1;
        if (this.currentFrame > this.maxFrame || this.currentFrame < 0) {
          
          // текущий кадр

          this.currentFrame = 0;
        }
        
        // выбор типа анимации взависимости от типа
        // переданных параметров:
        // картинки либо ссылки

        return this.type = typeof this.frames[this.currentFrame] === "string" ? "src" : "from";
      }

      
      // начало воспроизведения анимации

      play(frame) {
        
        // установка текущего кадра

        this.currentFrame = frame || this.currentFrame;
        if (this.currentFrame > this.maxFrame || this.currentFrame < 0) {
          
          // ограничение кадров

          this.currentFrame = 0;
        }
        if (this.intervals) {
          
          // текущий интервал между кадрами

          this.slowing = this.intervals[this.currentFrame];
        }
        
        // начинаем проигрывание

        return this.playing = true;
      }

      
      // пауза в анимации

      pause() {
        return this.playing = false;
      }

      
      // остановить анимацию

      stop() {
        this.playing = false;
        return this.currentFrame = 0;
      }

      update() {
        
        // идет ли проигрывание анимации

        if (this.playing) {
          
          // прибавляем счетчик

          this._counter++;
          
          // нужно ли загружать следующий кадр

          if (this.slowing === 1 || this._counter % this.slowing === 0) {
            
            // следующий кадр

            this.currentFrame++;
            this._counter = 0;
            
            // обработка превышения количества кадров

            if (this.currentFrame > this.maxFrame) {
              // зациклено
              if (this.loop) {
                this.currentFrame = 0;
              } else {
                // остановлено
                this.currentFrame = -1;
                this.playing = false;
              }
            }
            if (this.intervals) {
              
              // новый интервал для данного кадра

              this.slowing = this.intervals[this.currentFrame];
            }
            
            // если все еще проигрываем
            // и новый кадр не загружен

            if (this.playing && this.loadedFrame !== this.currentFrame) {
              
              // в зависимости от типа загружаем новый кадр

              switch (this.type) {
                case "src":
                  this.image.src(this.frames[this.currentFrame]);
                  break;
                case "from":
                  this.image.from(this.frames[this.currentFrame]);
                  break;
                case "set":
                  this.image.setRect(this.frameSet[this.currentFrame]);
              }
              
              // теперь загруженный кадр равен текущему

              return this.loadedFrame = this.currentFrame;
            }
          }
        }
      }

      _setOptions(options) {
        
        // номер отображаемого кадра

        this.currentFrame = options.currentFrame || 0;
        
        // номер последнего загруженного кадра

        this.loadedFrame = -1;
        
        // максимальное количество кадров в анимации

        this.maxFrame = options.maxFrame || 0;
        
        // замедление анимации

        this.slowing = options.slowing || 1;
        
        // счетчик для замедления анимации

        this._counter = 0;
        
        // нужно ли проигрывать анимацию по кругу

        this.loop = options.loop != null ? options.loop : true;
        
        // начинать ли воспроизведение автоматически после загрузки

        this.autoPlay = options.autoPlay != null ? options.autoPlay : true;
        
        // идет ли анимация в данный момент

        this.playing = false;
        
        // если нужно, используем массив интервалов,
        // отдельный интервал для каждого кадра

        return this.intervals = options.intervals || false;
      }

      _createImage(options) {
        var scene;
        
        // меняем тип в опциях для создания картинки

        options.type = "image";
        
        // сцена для анимации

        scene = options.scene;
        if (scene == null) {
          return;
        }
        
        // создаем картинку

        return this.image = scene.add(options);
      }

      
      // если работаем через from

      _setFrom(options) {
        if (Array.isArray(options.from)) {
          
          // массив картинок

          this.setFrames(options.from);
          
          // возвращаем новый from

          return this.frames[this.currentFrame];
        } else {
          
          // если не массив, то значение остается прежним

          return options.from;
        }
      }

      
      // если работаем через src

      _setSrc(options) {
        if (Array.isArray(options.src)) {
          
          // массив ссылок

          this.setFrames(options.src);
          
          // возвращаем новый src

          return this.frames[this.currentFrame];
        } else {
          
          // если не массив, то значение остается прежним

          return options.src;
        }
      }

      
      // если работаем через количество или размер кадров

      _setFrameCount(options) {
        var frameCount, frameSet, frameWidth, i, j, ref;
        
        // вычисляем количество и ширину кадров

        frameWidth = options.frameWidth || this.image.realSize[0] / options.frameCount;
        frameCount = options.frameCount || this.image.realSize[0] / options.frameWidth;
        
        // меняем размеры вывода картинки под размеры кадра

        this.image.resize([frameWidth, this.image.realSize[1]]);
        
        // а теперь получаем набор кадров

        frameSet = [];
        for (i = j = 0, ref = frameCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          frameSet.push([i * frameWidth, 0, frameWidth, this.image.realSize[1]]);
        }
        
        // и работаем через набор кадров

        return this.setFrameSet(frameSet);
      }

    };
  });

}).call(this);
